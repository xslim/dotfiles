#!/bin/sh

DIR_PATHS_FILE="${HOME}/.dirtydirs"
DIRTY_GIT_COMMIT=()
DIRTY_GIT_REMOTE=()

check_git() {
  [ -d "${1}/.git" ] || return
  
  if [[ -n "$(git -C ${1} status --porcelain)" ]]; then
		DIRTY_GIT_COMMIT+=(${1})
		return
	fi 
		
  if [[ -n "$(git -C ${1} log --branches --not --remotes --no-color --oneline)" ]]; then
		DIRTY_GIT_REMOTE+=(${1})
		return
	fi 
}

dirty_check() {
  local dir="$1"
  #echo "Checking ${dir}"	
  
  check_git $dir
}

print_dirty()
{
  declare -a arr=("${!2}")
  local msg="$1"
  local i

  if [ ${#arr[@]} != 0 ]; then
		echo "$msg:"
		for i in ${arr[@]}; do
      # Convert to relative path
	    local dir=${i/${HOME}/'~'}
			echo "  ${dir}"
		done
	fi
}

dirs=()


if [ "$1" == "." ]; then
  dirs+=("`pwd`")
elif [ -d "${1}" ]; then
  #echo "Checking directory"
  dirs+=("${1}")
elif [ "$1" == "list" ]; then
  cat ${DIR_PATHS_FILE}
elif [ "$1" == "edit" ]; then
  vi ${DIR_PATHS_FILE}
elif [ "$1" == "add" ]; then
  if [ "$2" == "." ]; then
    dir="`pwd`"
  elif [ -d "${2}" ]; then
    dir="${2}"
  else
    dir="`pwd`"
  fi 
  echo "Adding ${dir}"
  echo "${dir}" >> ${DIR_PATHS_FILE}
else
  IFS=$'\n' read -d '' -r -a dirs < ${DIR_PATHS_FILE}
  #echo "Loading paths: ${#dirs[@]}"
fi

for i in ${dirs[@]}; do
  dir="${i/#\~/$HOME}"
  dirty_check ${dir} 
done

print_dirty "Uncommitted files" DIRTY_GIT_COMMIT[@]
print_dirty "Unpushed changes" DIRTY_GIT_REMOTE[@]
